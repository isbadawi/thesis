In the previous chapter, we investigated the usage of various dynamic \matlab
features whose semantics are hard to reason about statically. Using the
insights gained there, in this chapter we present some techniques for
transforming code away from using these dynamic features in favor of
alternatives that are more amenable to static analysis.

\section{Motivation for eliminating uses of dynamic features}

While dynamic features are very powerful, for instance enabling metaprogramming
techniques that aren't otherwise possible, they are also have many drawbacks.

\subsection{Impact on static analysis and program comprehension}

Compilers and related tools rely on various static analyses to estimate the
runtime behavior of programs. Such analyses are typically conservative,
preferring to deduce weaker properties that are guaranteed to always hold for
all inputs over stronger properties that might not always hold, even if the
latter would be more useful. This ensures the soundness of any ensuing program
transformations (such as optimizations) predicated on those analyses.

Highly dynamic features tend to confuse traditional static analysis techniques.
For example, a call to \code{eval} can have nearly arbitrary side effects.
Without knowing the exact values passed as arguments -- information which is
rarely knowable statically -- encountering a call to \code{eval} forces a
conservative analysis to invalidate all the knowledge it has gathered thus far
and fall back on safe assumptions. As clients consume the analysis information,
this imprecision leads to missed optimization opportunities in compilers,
crippled code navigation features in IDEs, and spurious warnings in static
analyzers, among others.

\code{eval} is an easy example to pick on, being the most general and powerful
dynamic construct, but other dynamic features also lead to imprecision.
Changing the function lookup path obsoletes static information gathered about
the call graph. Reaching into another function's workspace and assigning to a
variable invalidates information about identifier lookup, making it hard to
distinguish between array accesses and function calls. Loading data via calls
to the \code{load} function complicates reasoning about the shapes of arrays.

\subsection{Performance}

One of the main observations of the previous section is that many uses of
dynamic features are completely superfluous, and could be equivalently written
using simpler, less powerful constructs of the language. In those cases, it
makes sense to consider the performance characteristics of the two approaches.

As an example, one of the principal patterns identified concerns using repeated
calls to the \code{eval} family of functions in a loop in lieu of using arrays.
The code in \lstref{Lst:EvalNoArray} calls \code{eval}, invoking the full
machinery of the interpreter, no fewer than eight times per loop iteration,
even though each of these could be replaced by two or three array operations.
Intuitively, we'd expect this to have a huge negative impact on performance.

Beyond interpreter overhead, code that restricts itself to features that are
easier to reason about statically is apt to be better understood by compilers,
which rely on sophisticated static analysis to identify candidates for
optimization. This is not irrelevant; several \matlab compilers exist, and
recent versions of the proprietary \matlab implementation include a JIT
compiler. % TODO(isbadawi): Could cite things here

% TODO(isbadawi): Numbers -- compare e.g. code using eval to equivalent
% static code.

\section{Eliminating uses of dynamic features}

Before considering any sort of heavy-duty, general approach to eliminating
uses of dynamic features, we instead exploit the fact that many of these
adhere to certain patterns.

To start with, we focus our attention on calls to \code{eval}. Consider a call
site $E$ of the form \code{eval(S)}, where $S$ stands for some \matlab
expression. Intuitively, if we're able to determine the value that $S$ will
evaluate to (say, some string $V$), then we can replace $E$ with $V$.
Mechanically, this is a simple operation to carry out; first parse $V$ using
our \matlab parser to obtain a fragment $T$ of an AST representing some
statement or expression, then replace the edge linking $E$ with its parent with
an edge linking $E$'s parent to $T$.

Of course, determining $V$ statically is likely impossible in general. However,
as we posit at the start of this chapter, those calls to \code{eval} that would
be truly hard to reason about statically are relatively rare. Even if we admit
defeat and restrict ourselves to dealing only with the low-hanging fruit, such
as calls with constant arguments, or the array-like calls we noticed earlier in
this chapter, we would still be going a long way towards solving this problem.

\subsection{Array-like calls to \code{eval}}

In the case of array-like calls to \code{eval}, there are really only two
patterns (with minor variations) that recur much of the time. The first, as
seen in \lstref{Lst:EvalNoArray}, involves constructing the argument with a
string concatenation, some of the constituent strings being string
literals, and others the result of calling \code{num2str} or \code{int2str} on
the loop variable. The second is similar, but uses \code{sprintf} instead of
string concatenation; \lstref{Lst:EvalNoArraySprintf} shows the example from
\lstref{Lst:EvalNoArray} rewritten in this style.

\lstinputlisting[
  language=Matlab,
  caption={The example from \lstref{Lst:EvalNoArray}, rewritten to use an
  alternative array-like \code{eval} pattern.},
  label=Lst:EvalNoArraySprintf,
  float
]{code/loopevalsprintf.m}

In both of these cases, the argument is constructed from a mix of static parts
and references to the loop variable, and it is easy to tell, just by
inspection, what the array-based alternative is.

\subsubsection{The algorithm}

Following this premise, a straightforward if simplistic algorithm to construct
a static replacement for such calls might work as follows.

\begin{itemize}

  \item Given a call $C$ to \code{eval} of one of these two forms, construct a
    template $t$ for the static replacement -- a string with placeholders for
    references to the loop variable. For example, for a call like
    \code{eval(['Y' numstr(i) '=Y(Ye,1);'])}, $t$ might be
    \code{'Y__i__=Y(Ye,1);'}. The mechanics of this step vary for the two
    patterns, but are straightforward in either case.

  \item $t$ is valid \matlab code -- only with plain identifiers instead
    of the array accesses -- so we can parse the template to get an AST $T$.

  \item Search $T$ for variable access expressions $e$ where the variable name
    $v$ contains our placeholders. For each such expression, do the following.

    \begin{itemize}

      \item Extract the placeholders out of $v$ (via e.g. a regular expression)
        to get a list of loop variables that the variable is parameterized by.

      \item Let $p$ be the portion of $v$ that remains after stripping the
        placeholders out (most often, $p$ is just a prefix of $v$).

      \begin{itemize}

        \item  If $p$ is empty, then replace $e$ with a reference to the loop
          variable corresponding to the placeholder. (We assume in this case
          there is only one placeholder).

        \item If $p$ is not empty, replace $e$ with a parameterized expression that
          has $p$ as the target, and an index for each placeholder present in
          $v$.

          As an edge case, it's possible that $p$ might already be used as a
          variable name; this happens in \lstref{Lst:EvalNoArray}, for instance,
          where \code{Y} is used as an array, and the first call to \code{eval}
          creates variables \code{Y1}, \code{Y2}, and so on. Any scheme to ensure
          $p$ is unique will do; arbitrarily, we append underscores to $p$ until
          it does not conflict with other variables.

      \end{itemize}

    \end{itemize}

  \item Replace $C$ with $T$ in the original AST.

\end{itemize}

\subsubsection{Caveats}

Array-like calls tend to come in packs, as seen in \lstref{Lst:EvalNoArray}.
Inside a given loop, array-like calls are apt to depend on the variables
defined by earlier array-like calls in the same loop. If we're not able to
eliminate one of these calls, for instance because it doesn't match our
patterns exactly, then it likely isn't safe to eliminate any of the calls in
the loop. We should therefore consider this an operation on loops, not function
calls. If we're not able to transform every array-like call inside a loop, then
we abort without making any changes.

More generally, array-like calls to \code{eval} create many variables, which
are then unified into array variables in the transformed code. If code after
the loop references those original variables, then the transformation isn't
safe to carry out as is.

Now it happens that these variables tend not to be referenced afterwards;
often, they're merely intermediate variables in some iterative computation.
However, we can still try and track down any post-loop uses and transform them
as well. In particular, we can reuse the template strings generated by the
algorithm to check whether a given variable name could possibly have been
defined by a given a call to \code{eval}. For instance, we can track the
definition of a variable named \code{X13} back to an array-like call to
\code{eval} where the template string was \code{'X__i__=abs(Y__i__)'}.

Finally, as mentioned in \secref{sec:Eval}, if \code{eval} encounters an error
while evaluating its argument, that error is silently ignored. Thus, if an
array-like call to \code{eval} has an off-by-one error in its logic, for
instance, that error would be swallowed, by when we reify the argument into
real code, that error might manifest at runtime as an array access out of
bounds error. While we don't expect such code to rely on the error semantics of
\code{eval}, the transformation wouldn't be semantics preserving if we simply
ignored them. However, simply wrapping each transformed statement in a
try/catch block to swallow any errors is poor style, and might have performance
implications besides. It's also unlikely that the user means to silence errors.
As a middle ground, we wrap the entire loop in a try/catch block, and output a
warning if the catch clause is reached.

\subsubsection{Effectiveness}

Since our approach relies on fairly simple-minded pattern matching, it might at
first glance appear quite brittle. To measure its effectiveness, we try to run
our eliminator on each of the 33 benchmarks mentioned in
\secref{sec:ArrayLikeEval}, and see for how many of those we're able to
eliminate every call to \code{eval}.
