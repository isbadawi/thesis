In the previous chapter, we investigated the usage of various dynamic \matlab
features whose semantics are hard to reason about statically. Using the
insights gained there, in this chapter we present some techniques for
transforming code away from using these dynamic features in favor of
alternatives that are more amenable to static analysis.

\section{Motivation for eliminating uses of dynamic features}

While dynamic features are very powerful, for instance enabling metaprogramming
techniques that aren't otherwise possible, they are also have many drawbacks.

\subsection{Impact on static analysis and program comprehension}

Compilers and related tools rely on various static analyses to estimate the
runtime behavior of programs. Such analyses are typically conservative,
preferring to deduce weaker properties that are guaranteed to always hold for
all inputs over stronger properties that might not always hold, even if the
latter would be more useful. This ensures the soundness of any ensuing program
transformations (such as optimizations) predicated on those analyses.

Highly dynamic features tend to confuse traditional static analysis techniques.
For example, a call to \code{eval} can have nearly arbitrary side effects.
Without knowing the exact values passed as arguments -- information which is
rarely knowable statically -- encountering a call to \code{eval} forces a
conservative analysis to invalidate all the knowledge it has gathered thus far
and fall back on safe assumptions. As clients consume the analysis information,
this imprecision leads to missed optimization opportunities in compilers,
crippled code navigation features in IDEs, and spurious warnings in static
analyzers, among others.

\code{eval} is an easy example to pick on, being the most general and powerful
dynamic construct, but other dynamic features also lead to imprecision.
Changing the function lookup path obsoletes static information gathered about
the call graph. Reaching into another function's workspace and assigning to a
variable invalidates information about identifier lookup, making it hard to
distinguish between array accesses and function calls. Loading data via calls
to the \code{load} function complicates reasoning about the shapes of arrays.

\subsection{Performance}

One of the main observations of the previous section is that many uses of
dynamic features are completely superfluous, and could be equivalently written
using simpler, less powerful constructs of the language. In those cases, it
makes sense to consider the performance characteristics of the two approaches.

As an example, one of the principal patterns identified concerns using repeated
calls to the \code{eval} family of functions in a loop in lieu of using arrays.
The code in \lstref{Lst:EvalNoArray} calls \code{eval}, invoking the full
machinery of the interpreter, no fewer than eight times per loop iteration,
even though each of these could be replaced by two or three array operations.
Intuitively, we'd expect this to have a huge negative impact on performance.

Beyond interpreter overhead, code that restricts itself to features that are
easier to reason about statically is apt to be better understood by compilers,
which rely on sophisticated static analysis to identify candidates for
optimization. This is not irrelevant; several \matlab compilers exist, and
recent versions of the proprietary \matlab implementation include a JIT
compiler. % TODO(isbadawi): Could cite things here

% TODO(isbadawi): Numbers -- compare e.g. code using eval to equivalent
% static code.

\section{Eliminating uses of dynamic features}

Before considering any sort of heavy-duty, general approach to eliminating
uses of dynamic features, we instead exploit the fact that many of these
adhere to certain patterns.

To start with, we focus our attention on calls to \code{eval}. Consider a call
site $E$ of the form \code{eval(S)}, where $S$ stands for some \matlab
expression. Intuitively, if we're able to determine the value that $S$ will
evaluate to (say, some string $V$), then we can replace $E$ with $V$.
Mechanically, this is a simple operation to carry out; first parse $V$ using
our \matlab parser to obtain a fragment $T$ of an AST representing some
statement or expression, then replace the edge linking $E$ with its parent with
an edge linking $E$'s parent to $T$.

Of course, determining $V$ statically is likely impossible in general. However,
as we posit at the start of this chapter, those calls to \code{eval} that would
be truly hard to reason about statically are relatively rare. Even if we admit
defeat and restrict ourselves to dealing only with the low-hanging fruit, such
as calls with constant arguments, or the array-like calls we noticed earlier in
this chapter, we would still be going a long way towards solving this problem.

\subsection{Array-like calls to \code{eval}}

In the case of array-like calls to \code{eval}, there are really only two
patterns (with minor variations) that recur much of the time. The first, as
seen in \lstref{Lst:EvalNoArray}, involves constructing the argument with a
string concatenation, some of the constituent strings being string
literals, and others the result of calling \code{num2str} or \code{int2str} on
the loop variable. The second is similar, but uses \code{sprintf} instead of
string concatenation; \lstref{Lst:EvalNoArraySprintf} shows the example from
\lstref{Lst:EvalNoArray} rewritten in this style.

\lstinputlisting[
  language=Matlab,
  caption={The example from \lstref{Lst:EvalNoArray}, rewritten to use an
  alternative array-like \code{eval} pattern.},
  label=Lst:EvalNoArraySprintf,
  float
]{code/loopevalsprintf.m}

In both of these cases, the argument is constructed from a mix of static parts
and references to the loop variable, and it is easy to tell, just by
inspection, what the array-based alternative is. Following this premise, a
straightforward if simplistic algorithm to construct a static replacement
for such calls might work as follows.

\begin{itemize}

  \item Given a call $C$ to \code{eval} of one of these two forms, construct a
    template $t$ for the static replacement -- a string with placeholders for
    references to the loop variable. For example, for a call like
    \code{eval(['Y' numstr(i) '=Y(Ye,1);'])}, $t$ might be
    \code{'Y__i__=Y(Ye,1);'}. The mechanics of this step vary for the two
    patterns, but are straightforward in either case.

  \item $t$ is valid \matlab code -- only with plain identifiers instead
    of the array accesses -- so we can parse the template to get an AST $T$.

  \item Search $T$ for variable access expressions $e$ where the variable name
    $v$ contains our placeholders. For each such expression, do the following.

    \begin{itemize}

      \item Extract the placeholders out of $v$ (via e.g. a regular expression)
        to get a list of loop variables that the variable is parameterized by.

      \item Replace $e$ with a parameterized expression, with an index for each
        placeholder present in $v$. The target of the expression is the portion
        of $v$ that remains after stripping the placeholders out -- most often,
        this is just a prefix of $v$.

    \end{itemize}

  \item Replace $C$ with $T$ in the original AST.

\end{itemize}
