Modern IDEs provide many useful code navigation facilities, for instance
allowing users to jump from a call site to the declaration of the called
function, or to find all the call sites of a particular function definition.
The reliability of such features is contingent on the availability of accurate
call graph information. However, \matlab's dynamic typing and dynamic features
complicate the problem of statically computing a precise call graph.

Previous work on \matlab call graph construction operated on a \matlab subset,
carefully ruling out those features which aren't amenable to static analysis,
with the ultimate goal of compiling \matlab to a statically typed language such
as \fortran or \xten \cite{Tamer}. As we mean to support regular \matlab
development, carving out such a subset is not an acceptable approach.

In this chapter, we present our approach to computing an accurate call graph
for arbitrary \matlab code. Rather than relying on static analysis, we extract
this information dynamically, by instrumenting the input programs and tracing
their actual execution on a \matlab implementation. This allows us to provide
precise code navigation even in the presence of features that have
traditionally been hard to reason about statically, such as calls to
\code{eval}. This precision comes at the cost of soundness, as the computed
call graphs are correct only with respect to a set of recorded program runs,
and some extra work for the programmer, whose responsibility it becomes to
provide entry points into the project that cover enough code to be useful.

\section{\matlab features complicating static call graph computation} \label{sec:MatlabLookup}

\matlab supports a limited form of function overloading or specialization. In
particular, it has a notion of \emph{superior} and \emph{inferior} types. While
the precise rules governing this relation are not documented anywhere, Dubrau
and Hendren, after exhaustively exercising each case, produced a diagram
(reproduced in \figref{fig:BuiltinClassRelationships}) describing the superior
and inferior relationships between the different builtin types \cite{Tamer}.
This relation is not a total ordering, as, for example, a given integer type is
neither superior nor inferior to the other integer types.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=5.2in]{figures/builtinClassRelationships.eps}
\caption{Superior/inferior type relationships for \matlab. An arrow points from
$a$ to $b$ if $a$ is superior to $b$.}
\label{fig:BuiltinClassRelationships}
\end{center}
\end{figure}

When a function call is evaluated, the arguments are evaluated first, and their
types influence the function lookup. In particular, \matlab identifies the most
superior argument type -- preferring the type of the leftmost superior argument
in case there is not a unique superior type -- and uses this as the call site's
"dominant type", say \code{char}. Then, a function defined in any directory
named \code{@char/} on \matlab's path will have priority over other
user-defined functions with the same name (with the exception of functions
nested inside the call site's enclosing function). Thus, in order to statically
compute a call graph in the presence of specialized functions, we need to carry
out type inference analysis to approximate these lookup semantics.

Although \matlab's functions are not quite first-class, a special kind of
object called a function handle can be used as a reference to a function,
either named or anonymous. These handles can be stored in variables, as well as
passed and returned from functions. Thus, in order to statically compute a call
graph in the presence of function handles, interprocedural analysis is required
to track which variables might hold function handles, and also which functions
each of these might point to.

In addition to these more traditional challenges, \matlab supports many highly
dynamic features that complicate any form of static analysis. Among these are
the evaluation of arbitrary strings as code via calls to the \code{eval} family
of functions, and a function lookup mechanism that involves crawling the
filesystem at runtime -- starting from a current directory that can be changed
at runtime -- in search of applicable call targets. More attention is paid to
these in \chapref{chap:DynamicFeatureElimination}.

\section{Call graph tracing instrumentation}

Since static analysis of \matlab code is difficult and easily misled in the
presence of dynamic features, we rely on dynamic analysis to extract
information that is sufficiently precise for our needs. Denker et al.
\cite{AbstractionsForDynamicAnalysis} identify different approaches available
to dynamic analysis tool developers for gathering runtime data:

\begin{itemize}
\item \emph{Source code modification} and, relatedly, \emph{logging services}.
This is the approach we ultimately use, as we discuss later.
\item \emph{Bytecode modification} or \emph{instrumenting the virtual machine}.
This requires knowledge of the internals of the \matlab virtual machine, and as
the reference \matlab implementation is a proprietary closed-source black box,
this isn't an option for us.
\item \emph{Method wrappers}. This refers to some mechanism for introducing
code to be executed before, after, or instead of a function. Our particular
source-to-source transformation, described later, can be seen of an instance of
this technique.
\item \emph{Debuggers}. While the reference \matlab implementation does include
a debugger, we prefer not to couple ourselves too tightly to it, as it is not
under our control.
\end{itemize}

The most natural and portable approach is source code modification. We can
implement it using the infrastructure provided as part of the \mclab toolkit.

The high-level idea is to insert logging statements before every possible call
site, and at the start of every function or script. After executing the
transformed code, we can post-process the logs and match up call sites with
their targets, since the target will follow the call in the log. We define a
unique identifier $identifier(n)$ for every call site and call target $n$; this
consists of the name of $n$ (the variable name if it's a variable, the function
name if it's a function definition, the script name if it's a script, and the
string \code{<lambda>} if it's an anonymous function expression), the file
it's contained in and its position (line and column) within that file. This
format comes in handy when it comes to implementing navigation features in an
IDE, as these typically take a textual range (e.g. a mouse selection) as input.

The transformation depends on a few functions (listed in
\figref{Fig:CallgraphRuntime}) being available at runtime. The
\code{mclab\_callgraph\_init} and \code{mclab\_callgraph\_log} functions
are straightforward; the former takes a path to a log file, creates it and
makes a handle to it globally accessible, while the latter takes a string and
writes it to the file. \newline \code{mclab\_callgraph\_log\_then\_run} is more
complicated; it takes a string, a variable (which is possibly a function
handle) and a variable number of arguments. If the given variable is a function
handle (either a function handle expression, or a variable that contains a
function handle), then we log the string to the file, and in either case we
forward the arguments to the variable.

\begin{figure}[htbp]
\lstinputlisting{code/callgraph_runtime.m}
\caption{The runtime components of the callgraph tracer.}
\label{Fig:CallgraphRuntime}
\end{figure}

Assuming these runtime functions are available, we traverse the whole project
and perform the following transformations.

\begin{itemize}

\item For every function or script $f$, we insert a call to
  \code{mclab\_callgraph\_log} as the first statement, passing the string
  \code{enter} followed by $identifier(f)$.

\item For every anonymous function definition $f$, we replace the body $b$ of the
  anonymous function with a call to \code{mclab\_callgraph\_log\_then\_run},
  passing the string \code{enter} followed by $identifier(f)$ as the first
  argument, and the original expression $b$ wrapped in an anonymous function
  expression taking no arguments as the second argument.

\item We replace every function call $n$ (as identified by the kind analysis)
  with a call to \code{mclab\_callgraph\_log\_then\_run}, passing the string
  \code{call} followed by $identifier(n)$ as the first argument, a handle to
  the target function as the second argument, and copies of the original
  arguments as the rest of the arguments.

  One caveat here is that there can be functions whose return value
  depends on the current execution context. For instance, \code{nargin} and
  \code{nargout} are builtin functions that return the number of input and
  output parameters passed to the current function. If we call these functions
  inside \code{mclab\_callgraph\_log\_then\_run} instead of the original
  function, they won't necessarily return the same value. As such, we avoid
  instrumenting calls to these functions, among other reflective functions such
  as \code{narginchk} and \code{inputname}. This doesn't really impact our
  precision, since these functions just return values, and can't for example
  call back into application code.

\item While the kind analysis distinguishes between function calls and variable
  accesses, it doesn't distinguish among the latter between array accesses and
  function handle invocations. In order to accurately trace control flow through
  function handles, we also instrument variable accesses in the same way as for
  function calls, only rather than passing in a function handle expression as
  the second argument, we just pass in the variable. At runtime,
  \code{mclab\_callgraph\_log\_then\_run} makes use of \matlab's reflective
  features to identify function handles, and only logs the call event in those
  cases. One small detail here is that an array access might have a colon
  literal as one of its arguments, and passing it to a function instead will
  cause \matlab to generate an error at runtime. In order for the
  transformation to be correct, we go through and replace any colon literals
  with colon string literals.

\end{itemize}

Finally, in order to trigger a tracing execution, an entry point is needed --
that is, a piece of code that will attempt to exercise as much of the subject
code as possible. This is handed off to the tracing machinery, which will first
instrument the project as described (in a temporary folder), create a temporary
file to hold the trace, and invoke \matlab, first calling
\code{mclab\_callgraph\_init} with the path to the log file, and then the
entry point. Once the execution is over, the trace is processed, and call
graph edges are identified by looking for \code{call} events that are
immediately followed by an \code{enter} event.

\figref{Fig:CallgraphBefore}, \figref{Fig:CallgraphAfter},
\figref{Fig:CallgraphTrace} and \figref{Fig:Callgraph} together show an
end-to-end example.

\begin{itemize}

\item \figref{Fig:CallgraphBefore} shows the application code.
  \code{for\_each\_file} recursively traverses a directory tree (using the
  builtin function \code{dir} as a primitive) and invokes a passed-in handler
  for each file with the given extension, making use of the helper functions
  \code{string\_ends\_with} and \code{is\_in} along the way. \code{code\_size}
  calls \code{for\_each\_file}, passing in a handle to the nested function
  \code{add\_size} as the handler. In \matlab, nested functions are closures,
  so that \code{add\_size} can read and write to the \code{total\_size}
  variable in the enclosing scope. In this way, \code{code\_size} adds up the
  sizes of all the m-files in the current directory.

\item \figref{Fig:CallgraphAfter} shows the same code after instrumentation
  (with all instances of the \code{mclab\_callgraph\_} prefix omitted for
  brevity).

\item \figref{Fig:CallgraphTrace} shows the generated trace, using an invocation
  of \code{code\_size()} as the entry point. Some events are omitted for brevity.

\item Finally, \figref{Fig:Callgraph} shows the call graph produced by
  processing the trace and matching up \code{call} and \code{enter} events.
  The call graph is in JSON format, mapping, for each covered call site, the
  call site's identifier to an array of function identifiers.

\end{itemize}

\begin{figure}[htbp]
\begin{minipage}{\linewidth}
  \lstinputlisting{code/callgraph-example/before/for_each_file.m}
\end{minipage}
\begin{minipage}{\linewidth}
  \lstinputlisting{code/callgraph-example/before/code_size.m}
\end{minipage}
\caption{The application code.}
\label{Fig:CallgraphBefore}
\end{figure}

\begin{figure}[htbp]
\begin{minipage}{\linewidth}
  \lstinputlisting{code/callgraph-example/after/for_each_file.m}
\end{minipage}
\begin{minipage}{\linewidth}
  \lstinputlisting{code/callgraph-example/after/code_size.m}
\end{minipage}
\caption{The same code after instrumentation.}
\label{Fig:CallgraphAfter}
\end{figure}

\begin{figure}[htbp]
\lstinputlisting[language={}]{code/callgraph-example/trace.txt}
\caption{The generated trace.}
\label{Fig:CallgraphTrace}
\end{figure}

\begin{figure}[htbp]
\lstinputlisting[language={}]{code/callgraph-example/graph.txt}
\caption{The generated call graph.}
\label{Fig:Callgraph}
\end{figure}

\section{Dealing with builtin and library functions} \label{sec:CallgraphBuiltins}

The abovementioned instrumentation can't be applied to \matlab builtin
functions. It could potentially be applied to library functions, assuming their
source code was available and they were written in \matlab and not native code.
That being said, if the goal is to enable useful code navigation features, then
instrumenting library functions is of dubious utility. In any case, during the
course of a profiling run, control flow is likely to be passed to a builtin or
otherwise uninstrumented function, which could then call back into the project
code, for instance via a passed-in function handle, a method call on a
passed-in object, or the use of \matlab's reflective features, possibly using
passed-in arguments to compute names of functions to call. Without taking
care to handle this correctly, then in the presence of such code, our approach
will be unsound, even with respect to the recorded execution.

As an illustrative example, consider the builtin function \code{arrayfun},
which takes a function handle $f$ and an array $a$ and applies $f$ to each
element in $a$, returning an array of the outputs, analogously to the
\code{map} function in functional languages. A call to \code{arrayfun} passing
in a handle to a user-defined function $f$ will manifest in the produced call
graph as an edge linking the call to \code{arrayfun} with $f$ directly, which
isn't quite correct. That information may still be useful for code navigation
purposes, with the understanding that we're tracking how control flow jumps
through application code, rather than focusing specifically on call sites and
their targets, but there again that's beyond the scope of a call graph
computation. A bigger problem occurs if $f$ itself calls a builtin function
$c$, as control would flow back to \code{arrayfun} which would invoke $f$
again, linking together the call to $c$ with $f$. Unlike the previous case,
this has no practical application, and is just wrong.

To preserve the soundness of our approach even in such cases, we rely on more
of \matlab's reflective features. In particular, the \code{functions} builtin
function allows us to inspect the contents of a function handle at runtime, and
determine which function it points to, the path to the file in which that
function was defined if applicable, and whether or not it's a builtin function.
Using this facility, we modify \code{mclab\_callgraph\_log\_then\_run} as shown
in \figref{Fig:LogThenRunBuiltin} to insert extra markers in the call trace in
order to distinguish calls to builtin functions. These markers are ignored by
the call graph construction step, but their presence in the trace separates
builtin call sites from user-defined function entrances, avoiding the addition
of the problematic edges.

\begin{figure}[htbp]
  \lstinputlisting{code/callgraph_builtins.m}
\caption{Code to handle builtins at runtime.}
\label{Fig:LogThenRunBuiltin}
\end{figure}

\section{Instrumentation performance overhead}

A priori, we expect the instrumented code to run at least an order of magnitude
or two slower than the original code, the main culprit being the wrapping of
every single function call or variable access with a call to an auxiliary
function. In order to get a sense of the magnitude of the overhead, we run some
benchmarks with and without instrumentation.

\subsection{Benchmarks}

We run our experiments on a set of 29 \matlab benchmarks. 23 of these are part
of the \mclab project's standard benchmark suite, which was collected from
various sources, including the FALCON and OTTER projects, Chalmers University
of Technology, the \matlab Central File Exchange, and the ACM CALGO library.
These benchmarks are mostly numerical algorithms, heavy on loops and array
reads and writes, and not so heavy on function calls or function handles. Most
\matlab code looks like this, so measuring and minimizing overhead on such code
is important. However, it's also important to evaluate our approach on code
where the tracing would reveal useful information. To that end, we also include
seven additional benchmarks in our suite. Six of these are numerical solvers, a
class of programs where it is common to operate on function handles. These are
the same benchmarks used by Lameed and Hendren to evaluate their work on
optimizing \code{feval} implementations \cite{OptimizingFeval}.

These benchmarks are described briefly in
\tableref{tab:InstrumentationBenchmarks}. In
\tableref{tab:InstrumentationBenchmarksInstrumentable}, we include some simple
static metrics to help understand the following experimental results. Since
instrumenting a function call or array access adds an overhead proportional to
the number of times it is executed, we note, for each benchmark, how many calls
or accesses are instrumented (this is the first number in each column), and how
many of these are inside loops (this is the number in parentheses in each
column). Note that this is computed is a relatively simple-minded way, and
doesn't catch, for example, calls or accesses inside functions which are called
inside loops. Nevertheless, this can be an interesting metric. The "Naive"
column refers to the instrumentation described thus far. We then show how each
optimization described later in this section affects this metric (in other
words, how many expressions we are able to avoid instrumenting). These are the
"+ Prop", "- Builtins", and "+ Checks" columns; their specific meanings are
described later in this section.

\begin{table}
  \begin{tabular}{| l | p{10cm} |}
  \hline
  Name & Description \\ \hline
  adpt        & Adaptive quadrature via Simpson's rule \\ \hline
  arsim       & Simulates autoregressive model \\ \hline
  bbai        & Babai estimation algorithm \\ \hline
  bubble      & Bubble sort \\ \hline
  capr        & Computes capacitance of a transmission line via finite difference and Gauss-Seidel methods \\ \hline
  clos        & Calculates transitive closure of a directed graph \\ \hline
  create      & Simulated maximum likelihood statistical regression \\ \hline
  crni        & Solves heat equation via Crank-Nicholson \\ \hline
  dich        & Solves Laplace's equation via Dirichlet \\ \hline
  diff        & Calculates diffraction pattern of monochromatic light \\ \hline
  fdtd        & Applies finite-difference time domain technique \\ \hline
  fft         & Computes discrete fast Fourier transform on complex data \\ \hline
  fiff        & Calculates finite difference solution to wave equation \\ \hline
  lgdr        & Calculates derivatives of Legendre polynomials \\ \hline
  mbrt        & Computes Mandelbrot sets \\ \hline
  mcpi        & Computes $\pi$ via Monte Carlo method \\ \hline
  nb1d        & Simulates 1-dimensional n-body problem \\ \hline
  nb3d        & Simulates 3-dimensional n-body problem \\ \hline
  numprime    & Sieve of Eratosthenes \\ \hline
  optstop     & Solves optimal stopping problem \\ \hline
  quadrature  & Integrates function via quadrature \\ \hline
  scra        & Computes reduced-rank approximation of matrix \\ \hline
  spqr        & Computes semi-pivoted QR decomposition of matrix \\ \hline
  bisect      & Finds root of scalar function via bisection method \\ \hline
  gaussQuad   & Composite Gauss-Legendre quadrature \\ \hline
  newton      & Finds root of scalar function via Newton's method \\ \hline
  odeEuler    & Integrates first order ODE via Euler's method \\\hline
  odeMidpt    & Integrates first order ODE via midpoint method \\ \hline
  odeRK4      & Integrates first order ODE via Runge-Kutta \\ \hline
  sim\_anl    & Minimizes function via simulated annealing \\ \hline
\end{tabular}
\caption{Call graph instrumentation benchmarks.}
\label{tab:InstrumentationBenchmarks}
\end{table}

\begin{table}
\centering
  \begin{tabular}{| l | l | l | l | l | l |}
  \hline
  Name & Naive & + Prop & - Builtins & + Checks \\ \hline
  adpt        & 31 (21) & 31 (21) & 17 (14)& 17 (14) \\ \hline
  arsim       & 19 (9) & 12 (3) & 2 (2) & 1 (1) \\ \hline
  bbai        & 13 (8) & 12 (7) & 6 (4) & 1 (1) \\ \hline
  bubble      & 7 (4) & 7 (4) & 5 (4) & 1 (0) \\ \hline
  capr        & 37 (29) & 37 (29) & 30 (28) & 5 (3) \\ \hline
  clos        & 2 (1) & 2 (1) & 1 (1) & 1 (1) \\ \hline
  create      & 86 (79) & 78 (71) & 60 (60) & 56 (56) \\ \hline
  crni        & 25 (19) & 21 (15) & 13 (11) & 2 (2) \\ \hline
  dich        & 25 (9) & 11 (3) & 1 (1) & 1 (1)  \\ \hline
  diff        & 14 (10) & 14 (10) & 1 (1) & 1 (1) \\ \hline
  fdtd        & 39 (30) & 9 (0) & 1 (0) & 1 (0) \\ \hline
  fft         & 17 (14) & 17 (14) & 13 (12) & 1 (0) \\ \hline
  fiff        & 22 (21) & 18 (17) & 1 (1) & 1 (0) \\ \hline
  lgdr        & 21 (15) & 12 (6) & 3 (3) & 3 (3) \\ \hline
  mbrt        & 11 (3) & 11 (3) & 2 (1) & 2 (1) \\ \hline
  mcpi        & 3 (2) & 3 (2) & 1 (0) & 1 (0) \\ \hline
  nb1d        & 26 (12) & 25 (11) & 9 (4) & 5 (0) \\ \hline
  nb3d        & 35 (20) & 23 (10) & 8 (5) & 6 (3) \\ \hline
  numprime    & 3 (2) & 3 (2) & 1 (0) & 6 (5) \\ \hline
  optstop     & 15 (14) & 9 (8) & 6 (5) & 6 (5) \\ \hline
  quadrature  & 2 (1) & 2 (1) & 2 (1) & 2 (1)\\ \hline
  scra        & 48 (35) & 47 (34) & 32 (28) & 24 (20) \\ \hline
  spqr        & 48 (35) & 42 (34) & 28 (28) & 20 (20) \\ \hline
  bisect      & 31 (7) & 31 (7) & 6 (2) & 4 (2) \\ \hline
  gaussQuad   & 53 (4) & 18 (2) & 4 (1) & 4 (1) \\ \hline
  newton      & 16 (5) & 16 (5) & 3 (2) & 3(2) \\ \hline
  odeEuler    & 7 (4) & 4 (1) & 2 (1) & 2(1) \\\hline
  odeMidpt    & 10 (7) & 5 (2) & 3 (2) & 3 (2) \\ \hline
  odeRK4      & 7 (4) & 5 (4) & 5 (4) & 5 (4) \\ \hline
  sim\_anl    & 19 (8) & 19 (8) & 11 (2) & 11 (2) \\ \hline
\end{tabular}
\caption{Instrumentable expressions in each benchmark.}
\label{tab:InstrumentationBenchmarksInstrumentable}
\end{table}

\subsection{Results}

The results are shown in \tableref{tab:InstrumentationResults}. All the
programs were executed on a machine with an Intel\textregistered \,
Core\texttrademark \, i7 CPU @ 2.4 GHz and 8 GB of memory, running OS X 10.9.4,
using \matlab version R2014b. For each benchmark, we show the running times of
the original code in seconds, and the slowdown of each instrumented version
relative to the original code. The columns refer to the same versions as in
\tableref{tab:InstrumentationBenchmarksInstrumentable}, and the specific
meaning of the "Better runtime" is given later in this section.

For the naive instrumentation described thus far, we see that the slowdown can
be extreme for some benchmarks, with six of the benchmarks undergoing a three
order of magnitude slowdown. All of these in the numerical category, and can be
optimized. The functional benchmarks all see a slowdown between one and two
orders of magnitude. While we're able to optimize them slightly, they tend to
stay within the same order of magnitude.

\begin{table}
\begin{tabular}{| l || l || l | l | l | l | l |}
  \hline
  Benchmark & Original & Naive & + Prop & - Builtins & + Checks & Better runtime \\ \hline
            & \multicolumn{1}{c||}{(s)} & \multicolumn{5}{c|}{Slowdowns} \\ \hhline{|=||=||=|=|=|=|=|}
  adpt        & 0.946 & 95.1 & 97.9 & 25.4 & 23.9 & 22.3  \\ \hline
  arsim       & 0.379 & 2.60 & 1.91 & 1.01 & 1.03 & 1.02  \\ \hline
  bbai        & 0.211 & 1.07 & 1.07 & 1.04 & 1.03 & 1.01  \\ \hline
  bubble      & 0.004 & 2.89 & 2.94 & 2.53 & 2.90 & 3.24  \\ \hline
  capr        & 10.6  & 1550 & 1530 & 1490 & 4.02 & 2.87  \\ \hline
  clos        & 0.521 & 1.03 & 1.01 & 1.06 & 1.03 & 1.03  \\ \hline
  create      & 0.033 & 2.31 & 2.88 & 1.52 & 1.75 & 1.54  \\ \hline
  crni        & 14.1  & 1120 & 751  & 743  & 1.17 & 1.10  \\ \hline
  dich        & 3.78  & 5340 & 2950 & 1.02 & 1.04 & 1.03  \\ \hline
  diff        & 1.24  & 1690 & 1660 & 1.02 & 1.05 & 1.09  \\ \hline
  fdtd        & 1.08  & 2.82 & 1.12 & 1.06 & 1.17 & 1.12  \\ \hline
  fft         & 1.95  & 217  & 216  & 213  & 2.05 & 2.28  \\ \hline
  fiff        & 4.83  & 2190 & 18.1 & 0.942& 0.922& 0.998 \\ \hline
  lgdr        & 0.017 & 2.65 & 2.37 & 1.70 & 2.11 & 2.46  \\ \hline
  mbrt        & 2.08  & 1490 & 1500 & 4.17 & 4.28 & 3.30  \\ \hline
  mcpi        & 0.008 & 2.57 & 2.57 & 2.10 & 2.30 & 2.71  \\ \hline
  nb1d        & 8.43  & 6.59 & 6.63 & 2.14 & 0.984& 0.96  \\ \hline
  nb3d        & 0.806 & 2.25 & 1.88 & 1.23 & 1.14 & 1.24  \\ \hline
  numprime    & 0.007 & 2.18 & 2.11 & 2.62 & 2.72 & 3.03  \\ \hline
  optstop     & 0.052 & 2.62 & 2.65 & 1.99 & 2.19 & 2.96 \\ \hline
  quadrature  & 0.005 & 3.34 & 3.29 & 3.29 & 3.84 & 3.67  \\ \hline
  scra        & 0.232 & 1.25 & 1.23 & 1.10 & 1.11 & 1.26  \\ \hline
  spqr        & 0.221 & 1.15 & 1.14 & 1.08 & 1.10 & 1.25  \\ \hline
  bisect      & 0.741 & 62.8 & 62.5 & 23.9 & 24.1 & 17.2  \\ \hline
  gaussQuad   & 1.73  & 20.1 & 18.9 & 10.9 & 10.8 & 11.8  \\ \hline
  newton      & 1.16  & 39.2 & 39.7 & 20.7 & 20.3 & 16.2  \\ \hline
  odeEuler    & 0.498 & 908  & 768  & 783  & 762  & 523   \\ \hline
  odeMidpt    & 0.553 & 754  & 655  & 657  & 650  & 471   \\ \hline
  odeRK4      & 0.614 & 872  & 775  & 771  & 784  & 481   \\ \hline
  sim\_anl    & 0.652 & 62.9 & 62.1 & 23.9 & 24.6 & 19.4  \\ \hhline{|=||=||=|=|=|=|=|}
  Geometric mean & 0.399 & 30.3 & 23.5 & 7.96 & 4.53 & 4.31 \\ \hline
\end{tabular}
\caption{Running times of the instrumented code with different optimizations
enabled.}
\label{tab:InstrumentationResults}
\end{table}

\subsection{Minimizing overhead}

The bulk of the runtime overhead of our approach stems from instrumenting each
function call and variable access, which is ultimately caused by our inability
to precisely distinguish arrays from function handles statically. Yet arrays
are apt to be much more common than function handles, so that the cost of
instrumenting each array access is disproportionate relative to the benefit.
Thus, we apply a few different techniques to try and minimize the amount of
array accesses that require instrumentation.

\subsubsection{Handle propagation analysis}

While the \mclab toolkit doesn't provide any facilities for performing
interprocedural static analysis on arbitrary \matlab code, we can still track
the flow of function handles through a single function. For each use of a
variable, we can estimate whether the variable holds only data, or a function
handle, or possibly a complex data structure with a mix of data and handles.
Where we're able to determine that a variable is definitely an array containing
only data, we can avoid instrumenting it. Some prior work had been done in this
direction inside the \mclab framework in the form of an intraprocedural
\emph{handle propagation analysis} -- work which we formalized and whose
implementation we completed.

The handle propagation analysis aims to compute, at each program point, which
variable possibly contain function handles. It's common to characterize
\matlab as a language where everything is a matrix -- even a scalar value is
actually a 1x1 matrix. Function handles, however, are not matrices. Broadly,
we distinguish between handles and structured data such as arrays, structs
or cell arrays. Then among these two categories we make some further
distinctions. In particular, the analysis deals with abstract values defined
as follows.

\begin{itemize}
  \item A variable could contain a function handle created via a function
    handle expression \code{@f}, which simply creates a handle to named
    function \code{f}. If so, we associate with the variable the abstract value
    $NAMED(f)$, keeping track of the name it points to.
  \item A variable could contain a function handle created via an anonymous
    function \code{@(x) expr(x)}. If so, we associate with the variable the
    abstract value $ANON(n)$, where $n$ is a reference to the
    anonymous function node in the AST.
  \item A variable could contain a function handle we don't have further
    information about. Typically this would happen if it was assigned the
    result of a call to a builtin function known to return handles. In that
    case we associate with the variable the abstract value $HANDLE$,
    abbreviated as $H$.
  \item A variable could contain structured data (for example a cell array),
    every element of which is a function handle. If so, we associate with it
    the abstract value $DHO$ (data, handle only).
  \item A variable could contain structured data where the elements are known
    to definitely not be handles. If so, we associate with it the abstract
    value $DO$ (data only).
  \item A variable could contain structured data which is a mix of handles
    and data, or where we don't know anything about the content. If so, we
    associate with the variable the abstract value $DWH$ (data with handles).
\end{itemize}

In addition to these, we have $\top$ and $\bot$ values, where $\top$ is the
most general value, and $\bot$ means the value is as yet undefined. The handle
propagation analysis is an intraprocedural forward dataflow analysis. At each
program point, it associates with each variable name a single abstract value.
The merge operation is the join $\vee$ of the partial order illustrated in
\figref{fig:HandleLattice}.

\begin{figure}
\centering
\begin{tikzpicture}
  \node (bot) at (0, 0) {$\bot$};
  \node (anon) at (-3, 1) {$ANON$};
  \node (named) at (-1, 1) {$NAMED$};
  \node (h) at (-2, 2) {$H$};
  \node (do) at (1, 1) {$DO$};
  \node (dho) at (3, 1) {$DHO$};
  \node (dwh) at (2, 2) {$DWH$};
  \node (top) at (0, 3) {$\top$};
  \draw [-] (bot) to (anon);
  \draw [-] (bot) to (named);
  \draw [-] (anon) to (h);
  \draw [-] (named) to (h);
  \draw [-] (bot) to (do);
  \draw [-] (bot) to (dho);
  \draw [-] (do) to (dwh);
  \draw [-] (dho) to (dwh);
  \draw [-] (h) to (top);
  \draw [-] (dwh) to (top);
\end{tikzpicture}
\caption{Handle propagation analysis abstract values.}
\label{fig:HandleLattice}
\end{figure}

To help with the definition of the analysis rules, we define a helper function
$struct$ operating on abstract values. In particular, it takes in a set of
abstract values and, interpreting them as the indvidual elements of an array or
cell array $a$, returns an abstract value representing $a$ itself. It is
defined as follows.

\begin{align*}
struct(V) &= \begin{cases}
  DO & \text{if } V = \lbrace DO \rbrace \\
  DHO & \text{if } V \subseteq \lbrace H, NAMED, ANON, DHO \rbrace \\
  DWH & \text{otherwise} \\
\end{cases} \\
\end{align*}

The analysis operates on a regular \matlab AST, using \mcsaf, the \mclab
toolkit's static analysis framework. When we encounter an assignment statement
$S$, we first examine the top-level expression $E$ on the right hand side, and
compute from it an abstract value $gen(E)$. The rules for this are shown in
\tableref{tab:HandleExprRules}, where we write $in(id)$ to refer to the
abstract value associated with the identifier $id$ in the in set of $S$, and
$kind(id)$ to refer to the kind analysis result for that identifier (either FN
or VAR, meaning the variable refers to a function or not, respectively). While
the analysis is intraprocedural over user-defined functions, an attempt is made
to avoid imprecision caused by calls to builtin functions in the form of a
table $knownBuiltins$, mapping, for a few hundred builtin functions, their name
to an abstract value representing their return value.

\tableref{tab:HandleStmtRules} shows how $gen(E)$ is used to compute the new
abstract value for the variable being assigned to, depending on the kind of
assignment (whether the variable is assigned to directly, or one of its
elements or fields is being assigned to). In each case, $id$ is the main
identifier being assigned to in $S$. The out set of $S$ is the same as the
in set, with the value for $id$ replaced by value in the right hand column.

\begin{table}
\begin{tabular}{l | l l}
  Expression $E$ & Abstract value $gen(E)$ \\ \hline
  \code{@name}    & $NAMED(name)$ \\ \hline
  \code{@(..)...} & $ANON(@(..)...)$ \\ \hline

  $id$ & $in(id)$ & if $kind(id) = VAR$ \\
       & $knownBuiltins(id)$ & if $kind(id) = FN \wedge id \in knownBuiltins$ \\
       & $\top$ & if $kind(id) = FN \wedge id \not \in knownBuiltins$ \\ \hline

  $id(\dots)$ & $knownBuiltins(id)$ & if $kind(id) = FN \wedge id \in knownBuiltins$ \\
              & $\top$ & if $kind(id) = FN \wedge id \not \in knownBuiltins$ \\
              & $knownBuiltins(f)$ & if $in(id) = NAMED(f) \wedge f \in knownBuiltins$ \\
              & $\top$ & if $in(id) \in \lbrace H, ANON, NAMED \rbrace $ \\
              & $in(id)$ & otherwise \\ \hline

  $id\lbrace\dots\rbrace$ & $ DO $ & if $in(id) = DO$ \\
  $id.\cdots$ & $ H $ & if $in(id) = DHO$ \\
              & $\top$ & $in(id) = DWH$ \\ \hline

  $\lbrace E_1, \dots, E_n \rbrace$ & $struct (\big\lbrace gen(E_1), \dots, gen(E_n) \big\rbrace)$ & \\
  $[ E_1, \dots, E_n ]$ & & \\ \hline
  any other expression & $DO$ & \\ \hline
\end{tabular}
\caption{Handle propagation analysis rules for expressions.}
\label{tab:HandleExprRules}
\end{table}

\begin{table}
\begin{tabular}{l | l l}
  Assignment & $out(id)$ & \\ \hline
  $id = E$ & $gen(E)$ & \\ \hline
  $id.\cdots = E$ & $in(id) \vee struct(\lbrace gen(E) \rbrace)$ & if $in(id) \in \lbrace DWH, DHO, DO \rbrace$ \\
  $id\lbrace\dots\rbrace = E$ & $DWH$ & otherwise \\
  $id(\dots) = E$ & & \\ \hline
\end{tabular}
\caption{Handle propagation analysis rules for assignments.}
\label{tab:HandleStmtRules}
\end{table}

For our purposes, if the target of a variable access is not a handle -- in
other words, if the abstract value associated with it is \code{DO}, \code{DHO}
or \code{DWH}, then we can safely abstain from instrumenting it. The "+ Prop"
column in \tableref{tab:InstrumentationResults} shows the performance of the
instrumented code with this enhancement applied (as a slowdown relative to the
uninstrumented code).

\subsubsection{Avoiding builtin call instrumentation}

\matlab code tends to be fraught with calls to builtin functions, and
instrumenting these won't give much benefit, since we don't have access to
their source code. However, because \matlab builtin functions can be shadowed
by user-defined functions with the same name, or specialized via the mechanism
described in \secref{sec:MatlabLookup}, we can't necessarily tell statically
whether a given function call is a call to a builtin function. Because of this,
the naive instrumentation goes ahead and instruments every function call, even
if it likely is a call to a builtin.

While we can't statically determine the target of a function call to check
whether it's a builtin, we can examine the application's code, as well as any
library code it depends on, in order to gather a list $A$ of user-defined
functions whose names conflict with builtin functions. In \matlab, a function's
name is the name of the file it's defined in (less the extension), so this is
just a simple filesystem traversal. Then, during instrumentation, when we
encounter a potential call to a builtin function, we check whether the name of
function appears in $A$. If it doesn't, then we can safely avoid instrumenting
the call. One assumption here is that we have access to all the code the user
is apt to run; this is not an unreasonable, given that the user is requesting a
call graph, and so is likely willing to provide all the relevant code.

We make a special exception for the builtin function \code{feval}, which is
often used to invoke function handles instead of the regular function call
syntax. There are two reasons for its prevalence. For one thing, in addition to
accepting function handles to invoke, \code{feval} also accepts names of
functions as strings, and it has become idiomatic in \matlab for library code
to offer similar interfaces -- accepting either handles or strings and
forwarding them to \code{feval} -- when a user-specified function is needed.
\code{feval} is also prevalent for historical reasons. Function handles were
added to the language with the release of \matlab 6 in 2000, but initially
could only be invoked via \code{feval}. Support for invoking function handles
with the regular function call syntax was not added until the release of
\matlab 7 in 2004. Given all this, we can almost view \code{feval} as an
alternative syntax for a function call. We therefore instrument all calls to
\code{feval}.

As as aside, in \secref{sec:CallgraphBuiltins}, we discussed the complications
caused by instrumenting calls to builtin functions. Even though we decide here
not to instrument direct calls to builtins, those complications still arise,
because function handles can point to builtin functions, and in those cases the
same problem traces -- with call events that don't have a corresponding enter
event -- can happen. Thus, the changes to the runtime described in that section
are still necessary.

The "- Builtins" column in \tableref{tab:InstrumentationResults} shows the
performance of the instrumented code with this enhancement applied.

\subsubsection{Checking type of function arguments at runtime}

Our instrumentation speculatively wraps each variable access in a function call
in case the variable is a function handle. A runtime check to determine whether
it is occurs inside this auxiliary function. This simplifies the
transformation, but is clearly wasteful if the variable turns out to be a plain
array variable, especially if the variable is accessed more than once. Since
\matlab is used a lot for numerical computations, \matlab code tends to be
heavy on loops, such that array variables are often accessed repeatedly,
magnifying the overhead. Intuitively, we should be able to check the type of a
given variable only once, and avoid instrumenting accesses to it at all if it's
not a function handle.

However, this presents a complication in terms of implementation complexity.
Wrapping each variable access in a function call is a very simple
transformation to make, as it just involves replacing an expression AST node
with another. If we start introducing conditionals, the transformation becomes
a lot more intrusive, since \matlab does not support any kind of conditional
expression (such as the ternary \code{\?:} operator in C-based languages), only
conditional statements. Thus, inserting checks at the right places while
preserving the order of operations requires destructuring the code into a kind
of three-address form.

The handle propagation analysis is precise enough in practice if we restrict
ourselves to a single function -- a lot of the imprecision occurs when arrays
are passed around as function parameters. As a simple middle groud, we create
two instrumented versions of each function. In the first version, we seed the
handle propagation analysis with the conservative assumption that any of the
function parameters might be a function handle (this is the same assumption
we've been using thus far). In the second, we seed it with the assumption that
all of the function parameters are definitely just plain data arrays. We then
replace the body of the function with an if statement, checking whether any of
the parameters are function handles, placing the naive first version in the
then branch, and the optimized second version in the else branch.

The "+ Checks" column in \tableref{tab:InstrumentationResults} shows the
performance of the instrumented code with this enhancement applied. For typical
\matlab benchmarks that are heavy on array operations, this drastically reduces
the overhead, although the runtime check itself does lead to slightly lower
performance in some of the benchmarks. For the benchmarks that do use function
handles, the effect on performance is negligible.

\subsubsection{Optimized runtime functions}

The optimizations described thus far aim to reduce the number of expressions
requiring instrumentation. This helps tremendously on our numerical benchmarks,
where the call graphs are actually empty, or contain a single edge linking a
call from the benchmark's driver function to the benchmark itself; in these
cases, we can reduce the overhead to be negligible. For those expressions
where instrumentation is actually needed, however, we also investigate the
runtime overhead associated with each function call.

After some profiling on a long-running benchmark, we identify the following
bottlenecks.

\begin{itemize}
  \item Our runtime uses the \code{fprintf} functions to log call and enter
    events to a log file. It turns out that by default, \matlab's
    implementation of \code{fprintf} flushes the output buffer each time the
    function is called, so that each of these calls is actually hitting the
    filesystem. For builtin functions, this happens three times per call.

    In addition to the usual \code{'w'} and \code{'a'} writing modes,
    \matlab's \code{fopen} function also accepts \code{'W'} and \code{'A'},
    which behave similarly to their lowercase couterparts, except that the
    output buffer is not flushed until it either reaches capacity or the file
    is closed (via the \code{fclose} function). Simply making this one
    character change in the \code{mclab\_callgraph\_init} functions leads to
    a 1.5x speedup.

  \item Function calls in \matlab are quite expensive. The
    \code{mclab\_callgraph\_log\_then\_run} calls \code{mclab\_callgraph\_log}
    to do the writing -- inlining this call leads to significant performance
    boost.
\end{itemize}

The "Better runtime" column in \tableref{tab:InstrumentationResults} shos
the performanced of the instrumented code with this enhancement applied.
