Modern IDEs provide many useful code navigation facilities, for instance
allowing users to jump from a call site to the declaration of the called
function, or to find all the call sites of a particular function definition.
The reliability of such features is contingent on the availability of accurate
call graph information. However, \matlab's dynamic typing and dynamic features
complicate the problem of statically computing a precise call graph.

Previous work on \matlab call graph construction operated on a \matlab subset,
carefully ruling out those features which aren't amenable to static analysis,
with the ultimate goal of compiling \matlab to a statically typed language such
as \fortran or \xten \cite{Tamer}. As we mean to support regular \matlab
development, carving out such a subset is not an acceptable approach.

In this chapter, we present our approach to computing an accurate call graph
for arbitrary \matlab code. Rather than relying on static analysis, we resort
to extracting this information dynamically, by instrumenting the input programs
and tracing their actual execution on a \matlab implementation.

\section{\matlab features complicating call graph computation}

\section{Call graph tracing instrumentation}

Since static analysis of \matlab code is difficult and easily misled in the
presence of dynamic features, we resort to dynamic analysis to extract
precision sufficient for our needs. Denker et al.
\cite{AbstractionsForDynamicAnalysis} identify different approaches available
to dynamic analysis tool developers for gathering runtime data:

\begin{itemize}
\item \emph{Source code modification} and, relatedly, \emph{logging services}.
This is the approach we ultimately use, as we discuss later.
\item \emph{Bytecode modification} or \emph{instrumenting the virtual machine}.
This requires knowledge of the internals of the \matlab virtual machine, and as
the reference \matlab implementation is a proprietary closed-source black box,
this isn't an option for us.
\item \emph{Method wrappers}. This refers to some mechanism for introducing
code to be executed before, after, or instead of a function. Our particular
source-to-source transformation, described later, can be seen of an instance of
this technique; we also, as an alternative, implement it using aspect-oriented
programming, which is perhaps closer to the intended meaning.
\item \emph{Debuggers}. While the reference \matlab implementation does include
a debugger, we prefer not to couple ourselves too tightly to it, as it is not
under our control.
\end{itemize}

The most natural and portable approach is source code modification. We can
implement using the infrastructure provided as part of the \mclab toolkit, and
also an AspectMatlab aspect, in order to compare the viability and performance
of the two approaches.

The high-level idea is to insert logging statements before every possible call
site, and at the start of every function or script. After executing the
transformed code, we can post-process the logs and match up call sites with
their targets, since the target will follow the call in the log. We identify
call sites by the file they're contained in and their position within that
file. This comes in handy when it comes to implementing navigation features in
an IDE, as these typically take a textual range (e.g. a mouse selection) as
input.

The transformation depends on a few functions (listed in
\figref{Fig:CallgraphRuntime}) being available at runtime. The
\texttt{mclab\_callgraph\_init} function takes a path to a log file, creates it, and
makes a handle to it globally accessible. The \texttt{mclab\_callgraph\_log} function
takes a string and writes it to the log file. The
\texttt{mclab\_callgraph\_log\_then\_run} function takes a string, a function handle,
and a variable number of arguments. It writes the string to the log file, then
forwards the input arguments to the function handle, returning any output
arguments the function handle returns.

\begin{figure}
\lstinputlisting[numbers=none]{code/callgraph_runtime.m}
\caption{The runtime components of the callgraph tracer.}
\label{Fig:CallgraphRuntime}
\end{figure}

Assuming these runtime functions are available, we traverse the whole project
and perform the following transformations. \figref{Fig:CallgraphBeforeAfter} shows
the effect of the transformation on a piece of \matlab code.

\begin{itemize}

\item For every function and script, we insert as the first statement a call to
  \texttt{mclab\_callgraph\_log}, which will output the name of the function or
  script, the file it's contained in, and its position within that file, along
  with a keyword "enter" that helps to distinguish between call sites and call
  targets.

\item We replace every function call with a call to
  \texttt{mclab\_callgraph\_log\_then\_run}, passing a similar identifying
  string as the first argument, a handle to the target function as the second
  argument, together with the arguments of the original call. One caveat here
  is that there can be functions whose return value depends on the current
  execution context. For instance, \texttt{nargin} and \texttt{nargout} are
  builtin functions that return the number of input and output parameters
  passed to the current function. If we call these functions inside
  \texttt{mclab\_callgraph\_log\_then\_run} instead of the original function,
  they won't necessarily return the same value. As such, we avoid instrumenting
  calls to these functions, among other reflective functions such as
  \texttt{narginchk} and \texttt{inputname}.

\end{itemize}

Finally, in order to trigger a tracing execution, an entry point is needed --
that is, a piece of code that will attempt to exercise as much of the subject
code as possible. This is handed off to the tracing machinery, which will first
instrument the project as described (in a temporary folder), create a temporary
file to hold the logs, and invoke \matlab, first calling
\texttt{mclab\_callgraph\_init} with the path to the log file, and then the
entry point. The log file can then be processed, and the \texttt{call} and
\texttt{enter} entries matched up.

\begin{figure}
\begin{minipage}{0.3\linewidth}
\lstinputlisting[numbers=none]{code/callgraph_before.m}
\end{minipage}
\hfill \hspace{.3cm} \hfill
\begin{minipage}{0.7\linewidth}
\lstinputlisting[numbers=none]{code/callgraph_after.m}
\end{minipage}
\caption{An example of the callgraph tracing transformation.}
\label{Fig:CallgraphBeforeAfter}
\end{figure}


\begin{figure}
\lstinputlisting[numbers=none]{code/callgraph_aspect.m}
\caption{The call graph tracer implemented as an aspect.}
\label{Fig:CallgraphAspect}
\end{figure}
