Modern IDEs provide many useful code navigation facilities, for instance
allowing users to jump from a call site to the declaration of the called
function, or to find all the call sites of a particular function definition.
The reliability of such features is contingent on the availability of accurate
call graph information. However, \matlab's dynamic typing and dynamic features
complicate the problem of statically computing a precise call graph.

Previous work on \matlab call graph construction operated on a \matlab subset,
carefully ruling out those features which aren't amenable to static analysis,
with the ultimate goal of compiling \matlab to a statically typed langauge such
as \fortran or \xten \cite{Tamer}. As we mean to support regular \matlab
development, carving out such a subset is not an acceptable approach.

In this chapter, we present our approach to computing an accurate call graph
for arbitrary \matlab code. Rather than relying on static analysis, we resort
to extracting this information dynamically, by instrumenting the input programs
and tracing their actual execution on a \matlab implementation.

\section{\matlab features complicating call graph computation}

\section{Call graph tracing instrumentation}

Since static analysis of \matlab code is difficult and easily misled in the
presence of dynamic features, we resort to dynamic analysis to extract
precision sufficient for our needs. Denker et al.
\cite{AbstractionsForDynamicAnalysis} identify different approaches available
to dynamic analysis tool developers for gathering runtime data:

\begin{itemize}
\item \emph{Source code modification} and, relatedly, \emph{logging services}.
This is the approach we ultimately use, as we discuss later.
\item \emph{Bytecode modification} or \emph{instrumenting the virtual machine}.
This requires knowledge of the internals of the \matlab virtual machine, and as
the reference \matlab implementation is a proprietary closed-source black box,
this isn't an option for us.
\item \emph{Method wrappers}. This refers to some mechanism for introducing
code to be executed before, after, or instead of a function. Our particular
source-to-source transformation, described later, can be seen of an instance of
this technique; we also, as an alternative, implement it using aspect-oriented
programming, which is perhaps closer to the intended meaning.
\item \emph{Debuggers}. While the reference \matlab implementation does include
a debugger, we prefer not to couple ourselves too tightly to it, as it is not
under our control.
\end{itemize}

The most natural and portable approach is source code modification. In
particular, we instrument programs to insert logging statements before each
possible call site, and at the start of each function, and then post-process
the logs generated by an execution to match up call sites and call targets.
We implement this using the infrastructure provided as part of the \mclab
toolkit, and also as an AspectMatlab aspect, in order to compare the viability
of the approaches.

\begin{figure}
\lstinputlisting[numbers=none]{code/callgraph_aspect.m}
\caption{The call graph tracer implemented as an aspect.}
\label{Fig:CallgraphAspect}
\end{figure}
